# 保护模式进阶

### 获取内存的方法
#### 1.0X15子功能0XE820
遍历主机上全部内存，每次调用返回一个地址范围描述符
（1）填写好“调用前输入”中列出的寄存器。
（2）执行中断调用 int 0x15。
（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。
#### 2.0X15子功能0XE801
分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。
（1）将 AX 寄存器写入 0xE801。
（2）执行中断调用 int 0x15。
（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果
#### 3.0x15子功能0X88
最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。
（1）将 AX 寄存器写入 0x88。
（2）执行中断调用 int 0x15。
（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

### 页表
*通过映射，使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续。*

#### 一级页表
![alt text](image.png)
整个虚拟地址空间被划分成许多虚拟页（4KB一页）；
页表是中每个元素（页表项）记录一个虚拟页对应的物理页框号 + 控制位。对应内存中一块实际的物理地址。将32位虚拟地址拆分为两个部分：**高20位用于定位一个物理页，低10位用于定位物理页内的偏移。**

#### 二级页表
将32位虚拟地址拆分成三部分：**高10位作为页表索引定位页目录项PDE、中间10位用于在页目录表中定义一个页表项PTE、低12位用于页内偏移量三部分**

虚拟地址 VA (32位) = | 页目录索引 10位 | 页表索引 10位 | 页内偏移 12位 |

最终实际物理地址计算方式为：高10位地址 * 4 + 中间10位地址 * 4 + 第12位地址

![alt text](image-1.png)

P 存在位 1表示该表在物理内存中，0为不在物理内存中
RW 读写位 1表示可读可写，0表示可读不可写
US 权限位 1表示任何权限可访问，0只允许3以上的权限访问
PWT 页级通写位 1表示采用通写方式（不光是普通内存，还是高速缓存）
PCD 高速缓存禁止位 1表示启用，0表示禁止
A 访问位 1表示已经被cpu访问过了，可以表示该页使用频率
D 脏页位 cpu对一个页面执行写操作时设为1，页目录不做修改
PAT 页属性表位 
G 全局位 为1为全局页，给出虚拟地址就知道物理地址
AVL 软件可用位

#### 二级页表标准分布
0号-768号项页表的3GB内存空间为用户空间，769号项指向下一个页表
769号-1022号项的1GB内存空间为内核空间，1022号项指向下一个页表
1023号项指向自己————为动态操作页表做准备

#### 启动分页机制
（1）准备好页目录表及页表。
（2）将页表地址写入控制寄存器 cr3。
（3）寄存器 cr0 的 PG 位置 1。

